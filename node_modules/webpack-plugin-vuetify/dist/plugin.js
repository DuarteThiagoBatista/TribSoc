"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VuetifyPlugin = void 0;
const path = require("upath");
const url_1 = require("url");
const loader_shared_1 = require("@vuetify/loader-shared");
// Can't use require.resolve() for this, it doesn't work with resolve.symlinks
let vuetifyBase;
async function getVuetifyBase(base, context, resolver) {
    if (!getVuetifyBase.promise) {
        let resolve;
        getVuetifyBase.promise = new Promise((_resolve) => resolve = _resolve);
        resolver.resolve({}, base, 'vuetify/package.json', context, (err, vuetifyPath) => {
            if (vuetifyPath) {
                vuetifyBase = path.dirname(vuetifyPath);
            }
            resolve(true);
        });
    }
    return getVuetifyBase.promise;
}
getVuetifyBase.promise = null;
function isSubdir(root, test) {
    const relative = path.relative(root, test);
    return relative && !relative.startsWith('..') && !path.isAbsolute(relative);
}
class VuetifyPlugin {
    constructor(options) {
        this.options = {
            autoImport: true,
            styles: true,
            stylesTimeout: 10000,
            ...options,
        };
    }
    apply(compiler) {
        if (this.options.autoImport) {
            compiler.options.module.rules.unshift({
                resourceQuery: query => {
                    if (!query)
                        return false;
                    const qs = new url_1.URLSearchParams(query);
                    return qs.has('vue') && (qs.get('type') === 'template' ||
                        (qs.get('type') === 'script' && qs.has('setup')));
                },
                use: { loader: require.resolve('./scriptLoader') },
            });
        }
        if (this.options.styles === 'none' ||
            this.options.styles === 'expose') {
            compiler.options.module.rules.push({
                enforce: 'pre',
                test: /\.css$/,
                include: /node_modules[/\\]vuetify[/\\]/,
                issuer: /node_modules[/\\]vuetify[/\\]/,
                loader: 'null-loader',
            });
        }
        else if (this.options.styles === 'sass') {
            compiler.hooks.normalModuleFactory.tap('vuetify-loader', factory => {
                factory.hooks.beforeResolve.tap('vuetify-loader', resolveData => {
                    if (resolveData.request.endsWith('.css') &&
                        isSubdir(path.dirname(require.resolve('vuetify/package.json')), resolveData.context)) {
                        const match = resolveData.request.match(/.*!(.+\.css)$/);
                        if (match) {
                            resolveData.request = match[1].replace(/\.css$/, '.sass');
                        }
                        else {
                            resolveData.request = resolveData.request.replace(/\.css$/, '.sass');
                        }
                    }
                });
            });
        }
        if (this.options.styles === 'expose') {
            const files = new Set();
            let resolve;
            let promise;
            let timeout;
            const blockingModules = new Set();
            const pendingModules = new Map();
            compiler.hooks.compilation.tap('vuetify-loader', (compilation, params) => {
                compilation.hooks.buildModule.tap('vuetify-loader', (module) => {
                    pendingModules.set(module.request, module);
                });
                compilation.hooks.succeedModule.tap('vuetify-loader', (module) => {
                    pendingModules.delete(module.request);
                    if (resolve &&
                        !Array.from(pendingModules.keys()).filter(k => !blockingModules.has(k)).length) {
                        resolve(false);
                    }
                });
            });
            const logger = compiler.getInfrastructureLogger('vuetify-loader');
            const awaitResolve = async (id) => {
                if (id) {
                    blockingModules.add(id);
                }
                if (!promise) {
                    promise = new Promise((_resolve) => resolve = _resolve);
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        logger.error('styles fallback timeout hit', {
                            blockingModules: Array.from(blockingModules.values()),
                            pendingModules: Array.from(pendingModules.values(), module => module.resource),
                        });
                        resolve(false);
                    }, this.options.stylesTimeout);
                    if (!Array.from(pendingModules.keys()).filter(k => !blockingModules.has(k)).length) {
                        resolve(false);
                    }
                    let start = files.size;
                    await promise;
                    clearTimeout(timeout);
                    blockingModules.clear();
                    if (files.size > start) {
                        await (0, loader_shared_1.writeStyles)(files);
                    }
                    promise = null;
                }
                return promise;
            };
            compiler.options.module.rules.push({
                enforce: 'pre',
                test: /\.s[ac]ss$/,
                loader: require.resolve('./styleLoader'),
                options: { awaitResolve },
            });
            compiler.options.resolve.plugins = compiler.options.resolve.plugins || [];
            compiler.options.resolve.plugins.push({
                apply(resolver) {
                    resolver
                        .getHook('resolve')
                        .tapAsync('vuetify-loader', async (request, context, callback) => {
                        var _a;
                        if (request.path && !vuetifyBase && request.request !== 'vuetify/package.json') {
                            await getVuetifyBase(request.path, context, resolver);
                        }
                        if (!(request.path &&
                            ((_a = request.request) === null || _a === void 0 ? void 0 : _a.endsWith('.css')) &&
                            isSubdir(vuetifyBase, request.path))) {
                            return callback();
                        }
                        resolver.resolve({}, request.path, request.request.replace(/\.css$/, '.sass'), context, (err, resolution) => {
                            if (resolution && !files.has(resolution)) {
                                awaitResolve();
                                files.add(resolution);
                            }
                            return callback();
                        });
                    });
                }
            });
        }
    }
}
exports.VuetifyPlugin = VuetifyPlugin;
//# sourceMappingURL=plugin.js.map